# Recommendations for node app in docker:
# https://snyk.io/blog/10-best-practices-to-containerize-nodejs-web-applications-with-docker/

# FIRST STAGE - INSTALL DEPENDENCIES, COMPILE
# ==============================================================================

# We do NOT need node image based on debian, so here I use minimal node-alpine
# image
FROM node:14-alpine AS build

# Locally I use npm v7
#   - by default node 14 has npm 6 for now
#   - package.json generated by npm v6 is not fully compatible with the one
#     generated by npm v7, so I am upgrading npm here
RUN npm install -g npm@^7

# WORKDIR affects:
#   - RUN
#   - ADD
#   - COPY
#   - ENTRYPOINT
#   - CMD
# Pifalls:
#   - ENV does NOT respect WORKDIR, so if you need to refer to a file in the ENV
#     you need to set the full path, e.g.:
#       - ENV AWS_IOT_CERTIFICATE=/app/certs/cert-name.pem
WORKDIR /app

# Copying rarely changed files
COPY ./package*.json ./tsconfig.json ./

# - Installing dependencies
#   - "ci" is continuous integration (for deterministic builds)
#   - "--only=production" installs only prod dependencies
#   - "--ignore-scripts" to ignore life-cycle scripts e.g.:
#   - "prepare" script is gonna be ignored because husky not needed in prod
# - Compiling (create compile command in package.json)
RUN npm ci --only=production --ignore-scripts && npm run compile

# SECOND STAGE - OPTIMIZE, PUBLISH, SERVE
# ==============================================================================

# Minimal node base image - node alpine
FROM node:14-alpine

# - "dumb-init" is a low footprint tool which
#   - runs as PID 1 process
#   - is able to spawn our app process as NOT PID 1 process
#   - ensures that all SIGNALS are passed to our app process
# - more details on dumb-init or similar in the CMD section below
RUN apk add dumb-init

# Some frameworks and libs may turn on the prod config only after setting
# NODE_ENV to "production" (in this case express for sure uses NODE_ENV)
ENV NODE_ENV=production

# USER directive only ensures that the process is owned by the "node" user
#   - if you COPY files without "--chown=node:node", they are gonna be owned
#     by root
#   - so later we also use "COPY --chown=node:node"
USER node

WORKDIR /app

# - Friends donâ€™t let friends run containers as root! :)
# - The official node Docker image and variants like alpine, include a
#   least-privileged user of the same name: "node"
# - Here we're changing 1. ownership and 2. group from "root" to "node"
#   - for details see chapter #4 in recommendation link above
# - We intentionally copy node_modules and dist from the build stage
#   - node_modules/ - dependcies
#   - dist/ - compiled code
COPY --chown=node:node --from=build /app/node_modules /app/node_modules
COPY --chown=node:node --from=build /app/dist /app/dist
COPY --chown=node:node . .

# CMD STANZA:
# - There are two ways how to specify the CMD directive in the Dockerfile:
#   - SHELL FORM notation - `CMD "node" "server.js"`
#       - the container spawns a shell interpreter that wraps the process
#       - shell may not properly forward signals to your process
#   - EXEC FORM notation - `CMD ["npm", "start"]`
#       - DIRECTLY spawns a process without wrapping it in a shell
#       - Any signals sent to the container are DIRECTLY sent to the process
# - Exec form for node app WITHOUT using npm is better than (see explanation
#   below):
#   - shell form version
#   - exec form WITH npm
# - Pitfalls: use DOUBLE QUOTES, single quotes will NOT work

# CMD ["node", "server.js"]
# - Here we invoke the node process DIRECTLY
#   - the node process does NOT get wrapped in an additional shell interpreter
#   - the node process will receive all signals sent to it
#   - node is gonna be PID 1, which poses a problem

# - When processes run as PID 1 they effectively take on some responsibilities
#   of an init system, which is typically responsible for initializing an OS
#   and processes
#    - the kernel treats PID 1 differently from process with other identifiers
#      like PID 2, PID 3... and so on
#    - special treatment from kernel means that SIGTERM signal to a running
#      process will NOT invoke default behavior of killing the process if the
#      process doesn't already set a handler for SIGTERM
# - NodeJs was NOT designed to run as a PID 1, which leads to unexpected
#   behavior when running inside the Docker
#    - e.g. Node process running as PID 1 will not respond to SIGINT
#      (`Ctrl + C`) and similar signals
# - We can use special tools, like "dumb-init" or similar which
#    - run as PID 1
#    - spawn the Node process NOT as PID 1
#    - ensure that all signals are passed to the Node process
#    - one of such tools is `dumb-init` - see `RUN apk add dumb-init`
CMD [ "dumb-init", "node", "./dist/main.js" ]
